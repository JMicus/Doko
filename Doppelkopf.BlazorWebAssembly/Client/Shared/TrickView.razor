@using C = Doppelkopf.Core.App;
@using Enums;


<div id="trick" class="frow" style="
    position: relative;
    margin: auto;
    width: 100%;
    height: 100%;
">

    <div class="fcol" style="
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        height: 100%;
        max-width: @((RelSize * _maxWidth) + "px");
        max-height: @((RelSize * _maxWidth) + "px")">
        @*height: r("hhghh")*@


        @foreach (var card in _cards)
        {

            <Card @ref=@_cardViews[card.NoInTrick - 1]
                  Layout=@Layout
                  AbsolutPosition=@true
                  Left=@card.Left
                  Top=@card.Top
                  Width=@r("ww")
                  Height=@r("hh")
                  Rotation=@card.Rotation
                  OnClick=@(card.OwnCard ? OnOwnCardClick : OnOtherCardClick) />

        }


        <div style="position: absolute; right: 0px; bottom: @(r("wwg"))">

            <DButton @ref=@_button
                    ImgName=@(Button == ButtonType.Take ? DButton.ButtonImgName.takeTrick : DButton.ButtonImgName.lastTrickBack)
                    Size=@ButtonSize
                    Visible=false
                    OnClick=@(x => OnButtonClick.InvokeAsync(x))>


            </DButton>
        </div>
        


    </div>

</div>


@code {

    private const float GAP_REL = .1f;

    public enum ButtonType
    {
        None, Take, Back
    }

    [Parameter]
    public C.Trick Trick { get; set; }

    [Parameter]
    public int PlayerNo { get; set; }

    [Parameter]
    public C.Layout Layout { get; set; }

    [Parameter]
    public double RelSize { get; set; } = 1;

    [Parameter]
    public EventCallback<object> OnButtonClick { get; set; }

    [Parameter]
    public EventCallback<C.Card> OnOwnCardClick { get; set; }

    //[Parameter]
    private EventCallback<C.Card> OnOtherCardClick { get; set; }

    [Parameter]
    public ButtonType Button { get; set; } = ButtonType.None;

    [Parameter]
    public DButton.ButtonSize ButtonSize { get; set; } = DButton.ButtonSize.Regular;

    private Card[] _cardViews = new Card[4];
    private DButton _button;

    private int _id = (new Random()).Next();
    private string Id => "trick-" + _id;

    private List<(int NoInTrick, string Left, string Top, int Rotation, bool OwnCard)> _cards { get; set; }

    private int _gap;
    private int _cw;
    private int _ch;
    private int _whGap;

    private double _maxWidth => 2 * _ch + 2 * _gap + _cw;

    private double _rel;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        _cw = int.Parse(Layout["cardWidth"]);
        _ch = int.Parse(Layout["cardHeight"]);

        //Console.WriteLine("Height: " + _ch);

        _gap = (int)(_ch * .1);
        //Console.WriteLine("gap: " + _gap);

        _whGap = (_ch - _cw);

        _rel = 100 / _maxWidth;
        //Console.WriteLine("rel: " + _rel);


        //var Trick = new[] { 0, 0, 0, 0, 0 };


        _cards = new List<(int, string, string, int, bool)>()
    {
            (1,  r("hhgg"),      r("hhgg"),  0, true),
            (2,  r("t"),         r("hg"),   -1, false),
            (3,  r("hhgg"),      r(""),      0, false),
            (4,  r("hhggwwggt"), r("hg"),    1, false)
        };

        Trick.OnChanged += StateHasChanged;

        //Console.WriteLine(_cw + " " + _ch + " " + _gap + " " + _whGap);
    }

    protected override bool ShouldRender()
    {
        Console.WriteLine("TrickView no render ");
        return false;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        Console.WriteLine("TrickView render " + (firstRender ? "(first)" : ""));
    }

    private string r(double x)
    {
        return (_rel * x).ToString().Replace(',', '.') + "%";
    }

    private string r(string spaceChars)
    {
        if (string.IsNullOrEmpty(spaceChars))
        {
            return "0%";
        }
        return r(spaceChars.ToCharArray()
                            .Select(c => (c == lower(c), lower(c)))
                            .Sum(p => double.Parse(p.Item2.ToString()
                                                            .Replace("g", _gap.ToString())
                                                            .Replace("w", _cw.ToString())
                                                            .Replace("h", _ch.ToString())
                                                            .Replace("t", _whGap.ToString()))
                           * (p.Item1 ? 1 : -1) / 2));
    }

    private char lower(char c)
    {
        return c.ToString().ToLower()[0];
    }

    private int playerPosition(int playerNo)
    {
        return (playerNo - PlayerNo + 4) % 4 + 1;
    }

    private int positionPlayer(int position)
    {
        for (var i = 1; i <= 4; i++)
        {
            if (playerPosition(i) == position)
            {
                return i;
            }
        }
        return -1;
    }


    //max-width: @(((_ch + _gap - _whGap) * 2 + _cw) + "px");
    //        max-height: @((int.Parse(Layout["cardHeight"]) + _gap* 2) + "px");

    public void Refresh(C.Trick trick)
    {
        Trick = trick;
        for (int i = 1; i <= 4; i++)
        {
            _cardViews[i - 1].Refresh(Trick[positionPlayer(i)]);
        }

        _button.Refresh(Button != ButtonType.None && Trick.Complete);
        //StateHasChanged();
    }
}
